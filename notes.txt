apf_vom_vector_claude_modifies

# ---------------------- Utility Functions ----------------------

def calculate_force(p1, p2, charge):
def calculate_distance(p1, p2):
def get_closest_point_on_rectangle(point, rect_center, rect_dims):

# ---------------------- Force Analysis Functions ----------------------

def calculate_force_metrics(current_pos, goal, obstacles, obstacle_dims, magnitude, prev_metrics=None):   change ratio trend logic |||||||||||||||||||||||||
def detect_local_minima_region(force_metrics):
def calculate_path_direction(path, current_pos, window=5):   change whole logic ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# ---------------------- VOM Placement and Force Adjustment ----------------------
def calculate_vom_placement(current_pos, force_metrics, prev_path, best_path, safe_distance=30.0):  
def adjust_vom_forces(current_pos, voms, force_metrics, desired_direction): change whole logic |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# second part ----------------------------------------------------------------------------------------------------------------------------------------->

# ---------------------- Path Generation Functions ----------------------
def calculate_next_position_with_voms(current, goal, obstacles, obstacle_dims, 
                                    voms, vom_charges, magnitude):
    """Calculate next position using closest points on rectangles"""
    # Attractive force to goal
    f_total = calculate_force(current, goal, charge=10.0 * (1 + magnitude/100))
    
    # Repulsive forces from obstacles with consistent p0
    p0 = 100.0  # Same influence range as in force_metrics
    for obstacle in obstacles:
        closest = get_closest_point_on_rectangle(current, obstacle, obstacle_dims)
        dist = calculate_distance(current, closest)
        
        if dist < p0:
            f_rep = calculate_force(current, closest, 
                                  charge=-2.0 * (1 - min(magnitude, 90)/100))
            # Scale force based on distance
            scale = (1 - dist/p0) * (1 - dist/p0)
            f_total += f_rep * scale
    
    # Add VOM forces with same scaling
    for vom, charge in zip(voms, vom_charges):
        dist = calculate_distance(current, vom)
        if dist < p0:
            f_vom = calculate_force(current, vom, charge=charge)
            scale = (1 - dist/p0) * (1 - dist/p0)
            f_total += f_vom * scale
    
    # Calculate movement
    if np.linalg.norm(f_total) > 0:
        direction = f_total / np.linalg.norm(f_total)
        shift = 5.0 * direction  # Fixed step size
        return current + np.ceil(shift)
    return current

def is_making_progress(current, last_progress, goal, threshold=5.0):
    """
    Check if making progress towards goal
    Returns True if moving closer to goal
    """
    curr_to_goal = calculate_distance(current, goal)
    last_to_goal = calculate_distance(last_progress, goal)
    return curr_to_goal < last_to_goal - threshold

def generate_enhanced_path(start, goal, obstacles, obstacle_dims, magnitude, prev_path, best_path=None):
    """Generate path with proactive local minima avoidance using best path reference"""
    path = [np.array(start)]
    current = np.array(start)
    virtual_obstacles = []
    vom_charges = []
    desired_direction = None
    
    # State tracking
    prev_metrics = None
    last_progress = current
    escape_attempts = 0
    max_iterations = 1000
    
    # Store initial movement direction for reference
    initial_dir = None
    
    print(f"\nAttempting path with magnitude {magnitude:.1f}")
    
    for iteration in range(max_iterations):
        # Calculate force metrics
        force_metrics = calculate_force_metrics(current, goal, obstacles, 
                                             obstacle_dims, magnitude, prev_metrics)
        
        # Store initial movement direction when we first start moving
        if initial_dir is None and len(path) > 1:
            initial_dir = path[-1] - path[-2]
            if np.linalg.norm(initial_dir) > 0:
                initial_dir = initial_dir / np.linalg.norm(initial_dir)
        
        # Proactive local minima detection
        approaching_minima, confidence, _ = detect_local_minima_region(force_metrics)
        
        # Progress tracking
        making_progress = is_making_progress(current, last_progress, goal)
        if making_progress:
            last_progress = current.copy()
            if len(virtual_obstacles) > 0:
                print(f"Progress: {calculate_distance(current, goal):.1f} units to goal")
        
        # VOM management - now more proactive and using best_path
        if approaching_minima and len(virtual_obstacles) == 0:
            print(f"Potential local minimum detected! Confidence: {confidence:.2f}")
            
            # Use both initial direction and best path for better VOM placement
            vom_pos, new_desired_dir = calculate_vom_placement(
                current, force_metrics, prev_path, best_path, safe_distance=30.0)
            
            # Validate VOM position against obstacles
            valid_position = True
            for obstacle in obstacles:
                if calculate_distance(vom_pos, obstacle) < obstacle_dims[0] + 10.0:
                    valid_position = False
                    break
            
            if valid_position:
                virtual_obstacles = [vom_pos]  # Single VOM
                vom_charges = [-2.0]
                desired_direction = new_desired_dir
                escape_attempts += 1
                print(f"Proactively placed VOM at {vom_pos}")
        
        # Remove VOM if making good progress or if VOM is not helping
        if virtual_obstacles:
            should_remove = False
            if making_progress:
                # Remove if far enough or consistently making progress
                if calculate_distance(current, virtual_obstacles[0]) > 50.0:  # Reduced from 100.0
                    should_remove = True
            
            if should_remove:
                print("Removed VOM - making progress")
                virtual_obstacles = []
                vom_charges = []
                desired_direction = None
        
        # Adjust VOM forces if needed
        if virtual_obstacles and desired_direction is not None:
            vom_charges = adjust_vom_forces(current, virtual_obstacles, 
                                         force_metrics, desired_direction)
            
        # Calculate next position including VOMs with reduced influence range
        next_pos = calculate_next_position_with_voms(
            current, goal, obstacles, obstacle_dims, 
            virtual_obstacles, vom_charges, magnitude)
        
        # Path smoothing: Average with previous direction if available
        if len(path) > 1:
            prev_dir = path[-1] - path[-2]
            if np.linalg.norm(prev_dir) > 0:
                prev_dir = prev_dir / np.linalg.norm(prev_dir)
                new_dir = next_pos - current
                if np.linalg.norm(new_dir) > 0:
                    new_dir = new_dir / np.linalg.norm(new_dir)
                    # Weighted average favoring new direction
                    smoothed_dir = 0.7 * new_dir + 0.3 * prev_dir
                    smoothed_dir = smoothed_dir / np.linalg.norm(smoothed_dir)
                    next_pos = current + 5.0 * smoothed_dir
        
        # Update position
        current = next_pos
        path.append(current)
        
        # Check if goal reached
        dist_to_goal = calculate_distance(current, goal)
        if dist_to_goal < 20.0:
            print(f"Goal reached in {len(path)} steps!")
            return path, force_metrics['closest_points'], virtual_obstacles, len(path)
        
        # Store metrics for next iteration
        prev_metrics = force_metrics
            
        # Break condition - only based on escape attempts now
        if escape_attempts > 3:  # Reduced from 5 since we're being proactive
            print(f"Path failed - Attempts: {escape_attempts}")
            print(f"Final distance to goal: {dist_to_goal:.1f}")
            return path, force_metrics['closest_points'], virtual_obstacles, float('inf')
            
    return path, force_metrics['closest_points'], virtual_obstacles, float('inf')

# ---------------------- Visualization Functions ----------------------
def draw_scene(image, start, goal, obstacles, obstacle_dims, paths_list, closest_points_list, voms_list):
    """Draw the scene with enhanced visualization"""
    def to_cv2_point(point):
        return (int(point[0]), -int(point[1]))
    
    # Clear image
    image.fill(0)
    
    # Draw obstacles
    for obstacle_center in obstacles:
        rect_width, rect_height = obstacle_dims
        top_left = np.array([obstacle_center[0] - rect_width, 
                           obstacle_center[1] + rect_height])
        bottom_right = np.array([obstacle_center[0] + rect_width, 
                               obstacle_center[1] - rect_height])
        cv2.rectangle(image, to_cv2_point(top_left), to_cv2_point(bottom_right), 
                     color=(0, 0, 255), thickness=-1)
    
    # Draw paths with different colors
    colors = [(100, 100, 255), (255, 255, 0)]  # Blue for test path, Yellow for best path
    
    for paths, voms, color in zip(paths_list, voms_list, colors):
        # Draw path with gradient
        if len(paths) > 1:
            for i in range(len(paths)-1):
                progress = i / max(1, len(paths)-1)
                # Interpolate color based on progress
                path_color = (
                    int(color[0] * (1-progress/2)),
                    int(color[1] * (progress/2)),
                    int(color[2] * (1-progress/2))
                )
                cv2.line(image, to_cv2_point(paths[i]), 
                        to_cv2_point(paths[i+1]), 
                        color=path_color, thickness=2)
        
        # Draw VOMs with influence radius
        for vom in voms:
            cv2.circle(image, to_cv2_point(vom), radius=10, 
                      color=(0, 150, 150), thickness=-1)
            cv2.circle(image, to_cv2_point(vom), radius=50, 
                      color=(0, 100, 100), thickness=1)
            
            # Draw direction indicators
            cv2.line(image, to_cv2_point(vom), 
                    to_cv2_point(vom + np.array([20, 0])),
                    color=(0, 200, 200), thickness=1)
    
    # Draw start and goal with labels
    cv2.circle(image, to_cv2_point(start), radius=20, 
              color=(50, 50, 0), thickness=1)
    cv2.putText(image, 'S', to_cv2_point(start - np.array([5, -5])),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (50, 50, 0), 1)
    
    cv2.circle(image, to_cv2_point(goal), radius=20, 
              color=(0, 255, 0), thickness=-1)
    cv2.putText(image, 'G', to_cv2_point(goal - np.array([5, -5])),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)

# ---------------------- Main Program ----------------------
def main():
    """Main program loop with dual path optimization"""
    # Initialize points and obstacles
    start = np.array([40, -440])
    goal = np.array([300, -140])
    prev_path = []
    best_path = None
    best_path_length = float('inf')
    
    window_name = 'Enhanced APF Path Planning'
    cv2.namedWindow(window_name)
    
    # Create trackbars for obstacles
    for i in range(1, 6):
        cv2.createTrackbar(f'Obstacle {i} X', window_name, 101 + (i-1)*50, 640, lambda x: None)
        cv2.createTrackbar(f'Obstacle {i} Y', window_name, 325 - (i-1)*15, 480, lambda x: None)
    
    # Path planning parameters
    magnitude = 50  # Starting magnitude
    mag_diff = 20   # Magnitude difference between paths
    mag_increment = 10  # How much to change magnitude between iterations
    best_magnitude = magnitude
    min_path_length = float('inf')
    obstacle_dims = np.array([20, 40])
    
    print("Starting Enhanced APF Path Planning")
    print("Controls: ESC - Exit, R - Reset")
    
    while True:
        image = np.zeros((480, 640, 3), dtype=np.uint8)
        
        # Get obstacle positions
        obstacles = []
        for i in range(1, 6):
            x = cv2.getTrackbarPos(f'Obstacle {i} X', window_name)
            y = cv2.getTrackbarPos(f'Obstacle {i} Y', window_name)
            obstacles.append(np.array([x, -y]))
        
        # Generate two paths with different magnitudes
        paths = []
        closest_points = []
        voms = []
        path_lengths = []
        
        # Current best magnitude path
        path1, cp1, v1, len1 = generate_enhanced_path(
            start, goal, obstacles, obstacle_dims, magnitude, prev_path, best_path)
        
        # Test path with different magnitude
        test_magnitude = magnitude + mag_diff
        path2, cp2, v2, len2 = generate_enhanced_path(
            start, goal, obstacles, obstacle_dims, test_magnitude, prev_path, best_path)
        
        # Update best path if either path is successful and better
        if len1 != float('inf'):  # path1 reached goal
            if len1 < best_path_length:
                best_path = path1.copy()  # Store copy to avoid reference issues
                best_path_length = len1
                print(f"New best path found! Length: {len1}")
        
        if len2 != float('inf'):  # path2 reached goal
            if len2 < best_path_length:
                best_path = path2.copy()
                best_path_length = len2
                print(f"New best path found! Length: {len2}")
        
        paths = [path1, path2]
        closest_points = [cp1, cp2]
        voms = [v1, v2]
        path_lengths = [len1, len2]
        
        # Update magnitude based on path lengths
        if path_lengths[0] < path_lengths[1]:
            magnitude = max(10, magnitude - mag_increment)
            prev_path = path1 if len1 != float('inf') else prev_path
            if len1 < min_path_length and len1 != float('inf'):
                min_path_length = len1
                best_magnitude = magnitude
        else:
            magnitude = min(300, magnitude + mag_increment)
            prev_path = path2 if len2 != float('inf') else prev_path
            if len2 < min_path_length and len2 != float('inf'):
                min_path_length = len2
                best_magnitude = magnitude + mag_diff
        
        # Visualization - also show best path if it exists
        paths_to_draw = [path1, path2]
        if best_path is not None:
            paths_to_draw.append(best_path)
            voms.append([])  # Add empty voms for best path visualization
        
        draw_scene(image, start, goal, obstacles, obstacle_dims, 
                  paths_to_draw, closest_points, voms)
        
        # Display info
        info_text = f"Magnitude: {magnitude:.1f} | Best: {best_magnitude:.1f} | Min Length: {min_path_length}"
        cv2.putText(image, info_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 
                    0.5, (255, 255, 255), 1)
        
        cv2.imshow(window_name, image)
        
        key = cv2.waitKey(1) & 0xFF
        if key == 27:  # ESC
            print("\nExiting program")
            break
        elif key == ord('r'):  # Reset
            print("\nResetting path planning")
            magnitude = 50
            prev_path = []
            best_path = None
            best_path_length = float('inf')
            min_path_length = float('inf')
        
    cv2.destroyAllWindows()


if __name__ == "__main__":
    main()